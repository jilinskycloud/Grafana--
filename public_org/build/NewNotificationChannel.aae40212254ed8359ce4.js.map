{"version":3,"file":"NewNotificationChannel.aae40212254ed8359ce4.js","sources":["webpack:////./public/app/features/alerting/NewAlertNotificationPage.tsx","webpack:////./public/app/features/alerting/components/NewNotificationChannelForm.tsx","webpack:////./public/app/features/alerting/components/NotificationChannelOptions.tsx","webpack:////./public/app/features/alerting/components/OptionElement.tsx","webpack:////./public/app/features/alerting/state/actions.ts"],"sourcesContent":["import React, { PureComponent } from 'react';\nimport { connect, MapDispatchToProps, MapStateToProps } from 'react-redux';\nimport { NavModel, SelectableValue } from '@grafana/data';\nimport { config } from '@grafana/runtime';\nimport { Form } from '@grafana/ui';\nimport Page from 'app/core/components/Page/Page';\nimport { NewNotificationChannelForm } from './components/NewNotificationChannelForm';\nimport { getNavModel } from 'app/core/selectors/navModel';\nimport { createNotificationChannel, loadNotificationTypes, testNotificationChannel } from './state/actions';\nimport { NotificationChannel, NotificationChannelDTO, StoreState } from '../../types';\n\ninterface OwnProps {}\n\ninterface ConnectedProps {\n  navModel: NavModel;\n  notificationChannels: NotificationChannel[];\n}\n\ninterface DispatchProps {\n  createNotificationChannel: typeof createNotificationChannel;\n  loadNotificationTypes: typeof loadNotificationTypes;\n  testNotificationChannel: typeof testNotificationChannel;\n}\n\ntype Props = OwnProps & ConnectedProps & DispatchProps;\n\nconst defaultValues: NotificationChannelDTO = {\n  name: '',\n  type: { value: 'email', label: 'Email' },\n  sendReminder: false,\n  disableResolveMessage: false,\n  frequency: '15m',\n  settings: {\n    uploadImage: config.rendererAvailable,\n    autoResolve: true,\n    httpMethod: 'POST',\n    severity: 'critical',\n  },\n  isDefault: false,\n};\n\nclass NewAlertNotificationPage extends PureComponent<Props> {\n  componentDidMount() {\n    this.props.loadNotificationTypes();\n  }\n\n  onSubmit = (data: NotificationChannelDTO) => {\n    /*\n      Some settings can be options in a select, in order to not save a SelectableValue<T>\n      we need to use check if it is a SelectableValue and use its value.\n    */\n    const settings = Object.fromEntries(\n      Object.entries(data.settings).map(([key, value]) => {\n        return [key, value.hasOwnProperty('value') ? value.value : value];\n      })\n    );\n\n    this.props.createNotificationChannel({\n      ...defaultValues,\n      ...data,\n      type: data.type.value,\n      settings: { ...defaultValues.settings, ...settings },\n    });\n  };\n\n  onTestChannel = (data: NotificationChannelDTO) => {\n    this.props.testNotificationChannel({\n      name: data.name,\n      type: data.type.value,\n      frequency: data.frequency ?? defaultValues.frequency,\n      settings: { ...Object.assign(defaultValues.settings, data.settings) },\n    });\n  };\n\n  render() {\n    const { navModel, notificationChannels } = this.props;\n\n    /*\n     Need to transform these as we have options on notificationChannels,\n     this will render a dropdown within the select.\n\n    TODO: Memoize?\n   */\n    const selectableChannels: Array<SelectableValue<string>> = notificationChannels.map(channel => ({\n      value: channel.value,\n      label: channel.label,\n      description: channel.description,\n    }));\n\n    return (\n      <Page navModel={navModel}>\n        <Page.Contents>\n          <h2>New Notification Channel</h2>\n          <Form onSubmit={this.onSubmit} validateOn=\"onChange\" defaultValues={defaultValues}>\n            {({ register, errors, control, getValues, watch }) => {\n              const selectedChannel = notificationChannels.find(c => c.value === getValues().type.value);\n\n              return (\n                <NewNotificationChannelForm\n                  selectableChannels={selectableChannels}\n                  selectedChannel={selectedChannel}\n                  onTestChannel={this.onTestChannel}\n                  register={register}\n                  errors={errors}\n                  getValues={getValues}\n                  control={control}\n                  watch={watch}\n                  imageRendererAvailable={config.rendererAvailable}\n                />\n              );\n            }}\n          </Form>\n        </Page.Contents>\n      </Page>\n    );\n  }\n}\n\nconst mapStateToProps: MapStateToProps<ConnectedProps, OwnProps, StoreState> = state => {\n  return {\n    navModel: getNavModel(state.navIndex, 'channels'),\n    notificationChannels: state.alertRules.notificationChannels,\n  };\n};\n\nconst mapDispatchToProps: MapDispatchToProps<DispatchProps, OwnProps> = {\n  createNotificationChannel,\n  loadNotificationTypes,\n  testNotificationChannel,\n};\n\nexport default connect(mapStateToProps, mapDispatchToProps)(NewAlertNotificationPage);\n","import React, { FC, useEffect } from 'react';\nimport { css } from 'emotion';\nimport { GrafanaTheme, SelectableValue } from '@grafana/data';\nimport {\n  Button,\n  Field,\n  FormAPI,\n  HorizontalGroup,\n  InfoBox,\n  Input,\n  InputControl,\n  Select,\n  stylesFactory,\n  Switch,\n  useTheme,\n} from '@grafana/ui';\nimport { NotificationChannel, NotificationChannelDTO } from '../../../types';\nimport { NotificationChannelOptions } from './NotificationChannelOptions';\n\ninterface Props extends Omit<FormAPI<NotificationChannelDTO>, 'formState'> {\n  selectableChannels: Array<SelectableValue<string>>;\n  selectedChannel?: NotificationChannel;\n  imageRendererAvailable: boolean;\n\n  onTestChannel: (data: NotificationChannelDTO) => void;\n}\n\nexport const NewNotificationChannelForm: FC<Props> = ({\n  control,\n  errors,\n  selectedChannel,\n  selectableChannels,\n  register,\n  watch,\n  getValues,\n  imageRendererAvailable,\n  onTestChannel,\n}) => {\n  const styles = getStyles(useTheme());\n\n  useEffect(() => {\n    watch(['type', 'settings.priority', 'sendReminder', 'uploadImage']);\n  }, []);\n\n  const currentFormValues = getValues();\n  return (\n    <>\n      <div className={styles.basicSettings}>\n        <Field label=\"Name\" invalid={!!errors.name} error={errors.name && errors.name.message}>\n          <Input name=\"name\" ref={register({ required: 'Name is required' })} />\n        </Field>\n        <Field label=\"Type\">\n          <InputControl\n            name=\"type\"\n            as={Select}\n            options={selectableChannels}\n            control={control}\n            rules={{ required: true }}\n          />\n        </Field>\n        <Field label=\"Default\" description=\"Use this notification for all alerts\">\n          <Switch name=\"isDefault\" ref={register} />\n        </Field>\n        <Field label=\"Include image\" description=\"Captures an image and include it in the notification\">\n          <Switch name=\"settings.uploadImage\" ref={register} />\n        </Field>\n        {currentFormValues.uploadImage && !imageRendererAvailable && (\n          <InfoBox title=\"No image renderer available/installed\">\n            Grafana cannot find an image renderer to capture an image for the notification. Please make sure the Grafana\n            Image Renderer plugin is installed. Please contact your Grafana administrator to install the plugin.\n          </InfoBox>\n        )}\n        <Field\n          label=\"Disable Resolve Message\"\n          description=\"Disable the resolve message [OK] that is sent when alerting state returns to false\"\n        >\n          <Switch name=\"disableResolveMessage\" ref={register} />\n        </Field>\n        <Field label=\"Send reminders\" description=\"Send additional notifications for triggered alerts\">\n          <Switch name=\"sendReminder\" ref={register} />\n        </Field>\n        {currentFormValues.sendReminder && (\n          <>\n            <Field\n              label=\"Send reminder every\"\n              description=\"Specify how often reminders should be sent, e.g. every 30s, 1m, 10m, 30m or 1h etc.\"\n            >\n              <Input name=\"frequency\" ref={register} />\n            </Field>\n            <InfoBox>\n              Alert reminders are sent after rules are evaluated. Therefore a reminder can never be sent more frequently\n              than a configured alert rule evaluation interval.\n            </InfoBox>\n          </>\n        )}\n      </div>\n      {selectedChannel && (\n        <NotificationChannelOptions\n          selectedChannel={selectedChannel}\n          currentFormValues={currentFormValues}\n          register={register}\n          errors={errors}\n          control={control}\n        />\n      )}\n      <HorizontalGroup>\n        <Button type=\"submit\">Save</Button>\n        <Button type=\"button\" variant=\"secondary\" onClick={() => onTestChannel(getValues({ nest: true }))}>\n          Test\n        </Button>\n        <Button type=\"button\" variant=\"secondary\">\n          Back\n        </Button>\n      </HorizontalGroup>\n    </>\n  );\n};\n\nconst getStyles = stylesFactory((theme: GrafanaTheme) => {\n  return {\n    basicSettings: css`\n      margin-bottom: ${theme.spacing.xl};\n    `,\n  };\n});\n","import React, { FC } from 'react';\nimport { SelectableValue } from '@grafana/data';\nimport { Field, FormAPI, InfoBox } from '@grafana/ui';\nimport { OptionElement } from './OptionElement';\nimport { NotificationChannel, NotificationChannelDTO, Option } from '../../../types';\n\ninterface Props extends Omit<FormAPI<NotificationChannelDTO>, 'formState' | 'getValues' | 'watch'> {\n  selectedChannel: NotificationChannel;\n  currentFormValues: NotificationChannelDTO;\n}\n\nexport const NotificationChannelOptions: FC<Props> = ({\n  control,\n  currentFormValues,\n  errors,\n  selectedChannel,\n  register,\n}) => {\n  return (\n    <>\n      <h3>{selectedChannel.heading}</h3>\n      {selectedChannel.info !== '' && <InfoBox>{selectedChannel.info}</InfoBox>}\n      {selectedChannel.options.map((option: Option, index: number) => {\n        const key = `${option.label}-${index}`;\n\n        // Some options can be dependent on other options, this determines what is selected in the dependency options\n        // I think this needs more thought.\n        const selectedOptionValue =\n          currentFormValues[`settings.${option.showWhen.field}`] &&\n          (currentFormValues[`settings.${option.showWhen.field}`] as SelectableValue<string>).value;\n\n        if (option.showWhen.field && selectedOptionValue !== option.showWhen.is) {\n          return null;\n        }\n\n        return (\n          <Field\n            key={key}\n            label={option.label}\n            description={option.description}\n            invalid={errors.settings && !!errors.settings[option.propertyName]}\n            error={errors.settings && errors.settings[option.propertyName]?.message}\n          >\n            <OptionElement option={option} register={register} control={control} />\n          </Field>\n        );\n      })}\n    </>\n  );\n};\n","import React, { FC } from 'react';\nimport { FormAPI, Input, InputControl, Select, Switch, TextArea } from '@grafana/ui';\nimport { Option } from '../../../types';\n\ninterface Props extends Pick<FormAPI<any>, 'register' | 'control'> {\n  option: Option;\n}\n\nexport const OptionElement: FC<Props> = ({ control, option, register }) => {\n  const modelValue = `settings.${option.propertyName}`;\n  switch (option.element) {\n    case 'input':\n      return (\n        <Input\n          type={option.inputType}\n          name={`${modelValue}`}\n          ref={register({\n            required: option.required ? 'Required' : false,\n            validate: v => (option.validationRule !== '' ? validateOption(v, option.validationRule) : true),\n          })}\n          placeholder={option.placeholder}\n        />\n      );\n\n    case 'select':\n      return <InputControl as={Select} options={option.selectOptions} control={control} name={`${modelValue}`} />;\n\n    case 'textarea':\n      return (\n        <TextArea\n          name={`${modelValue}`}\n          ref={register({\n            required: option.required ? 'Required' : false,\n            validate: v => (option.validationRule !== '' ? validateOption(v, option.validationRule) : true),\n          })}\n        />\n      );\n\n    case 'switch':\n      return (\n        <Switch\n          name={`${modelValue}`}\n          ref={register({\n            required: option.required ? 'Required' : false,\n          })}\n        />\n      );\n\n    default:\n      console.error('Element not supported', option.element);\n      return null;\n  }\n};\n\nconst validateOption = (value: string, validationRule: string) => {\n  return RegExp(validationRule).test(value) ? true : 'Invalid format';\n};\n","import { AppEvents } from '@grafana/data';\nimport { getBackendSrv } from '@grafana/runtime';\nimport { AlertRuleDTO, NotifierDTO, ThunkResult } from 'app/types';\nimport { appEvents } from 'app/core/core';\nimport { updateLocation } from 'app/core/actions';\nimport { loadAlertRules, loadedAlertRules, setNotificationChannels } from './reducers';\n\nexport function getAlertRulesAsync(options: { state: string }): ThunkResult<void> {\n  return async dispatch => {\n    dispatch(loadAlertRules());\n    const rules: AlertRuleDTO[] = await getBackendSrv().get('/api/alerts', options);\n    dispatch(loadedAlertRules(rules));\n  };\n}\n\nexport function togglePauseAlertRule(id: number, options: { paused: boolean }): ThunkResult<void> {\n  return async (dispatch, getState) => {\n    await getBackendSrv().post(`/api/alerts/${id}/pause`, options);\n    const stateFilter = getState().location.query.state || 'all';\n    dispatch(getAlertRulesAsync({ state: stateFilter.toString() }));\n  };\n}\n\nexport function createNotificationChannel(data: any): ThunkResult<void> {\n  return async dispatch => {\n    try {\n      await getBackendSrv().post(`/api/alert-notifications`, data);\n      appEvents.emit(AppEvents.alertSuccess, ['Notification created']);\n      dispatch(updateLocation({ path: 'alerting/notifications' }));\n    } catch (error) {\n      appEvents.emit(AppEvents.alertError, [error.data.error]);\n    }\n  };\n}\n\nexport function testNotificationChannel(data: any): ThunkResult<void> {\n  return async () => {\n    await getBackendSrv().post('/api/alert-notifications/test', data);\n  };\n}\n\nexport function loadNotificationTypes(): ThunkResult<void> {\n  return async dispatch => {\n    const alertNotifiers: NotifierDTO[] = await getBackendSrv().get(`/api/alert-notifiers`);\n\n    const notificationTypes = alertNotifiers\n      .map((option: NotifierDTO) => {\n        return {\n          value: option.type,\n          label: option.name,\n          ...option,\n          typeName: option.type,\n        };\n      })\n      .sort((o1, o2) => {\n        if (o1.name > o2.name) {\n          return 1;\n        }\n        return -1;\n      });\n\n    dispatch(setNotificationChannels(notificationTypes));\n  };\n}\n"],"mappings":"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","sourceRoot":""}